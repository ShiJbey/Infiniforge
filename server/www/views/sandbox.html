<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infiniforge Sandbox</title>
    <link rel="stylesheet" type="text/css" href="/style/style.css" >
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
</head>

<body>
    <div id="container">
        <canvas id="threejs-canvas"></canvas>
        <a id="download-button" href="javascript: void(0)" download="sword.gltf">
            <button>
                Download glTF
            </button>
        </a>
    </div>

    <script type="module">
        import * as dat from '/node_modules/dat.gui.module.js';
        import * as THREE from '/node_modules/three.module.js';
        import { GLTFLoader } from '/js/GLTFLoader.js';
        import { OrbitControls } from '/js/OrbitControls.js';
        import { getRandomInt, randomSeed } from '/js/utils.js';

        let scene, camera, renderer, controls;
        let swordModel, material, importedMaterial;
        let useWireFrame;
        let generationParams;
        let gui;
        let seedController, baseWidthController;
        let swordglTF;

        let wireFrameEnabled = false;
        let wireframeMaterial = new THREE.MeshBasicMaterial({
            color: 0x050505,
            wireframe: true
        });


        init();
        animate();

        function forgeSword() {
            var data = JSON.stringify(forgeParams);

            var xhr = new XMLHttpRequest();
            xhr.withCredentials = true;

            xhr.addEventListener("readystatechange", function() {
                if(this.readyState === 4) {
                    console.log(JSON.parse(this.response));
                }
            });

            xhr.open("POST", "/api/forge/sword");
            xhr.setRequestHeader("Content-Type", "application/json");

            xhr.send(data);
        }

        function loadModel(data) {
            var loader = new GLTFLoader();
            loader.parse(
                JSON.stringify(data),
                '',
                (gltf) => {
                    scene.remove(swordModel);
                    swordModel = gltf.scene.children[0];
                    swordModel.rotation.y += Math.PI / 2;
                    importedMaterial = swordModel.material;
                    scene.add(swordModel);
                    // Save the json
                    swordglTF = res;
                    // Toggle the download
                    setGlTFDownload(true);
                },
                (err) => {
                    alert(err);
                });
        }

        function init() {
            var ThreeJSCanvas = document.getElementById("threejs-canvas");

            renderer = new THREE.WebGLRenderer({ canvas: ThreeJSCanvas, antialias: true });
            var renderer_rect = renderer.domElement.getBoundingClientRect();
            renderer.setSize(renderer_rect.width, renderer_rect.height);
            renderer.setPixelRatio(window.devicePixelRatio);

            var aspect = renderer_rect.width / renderer_rect.height;
            camera = new THREE.PerspectiveCamera(75, aspect, 1, 1000);
            camera.position.z = 2;
            camera.updateProjectionMatrix();

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);

            // controls

			controls = new OrbitControls( camera, renderer.domElement );

            //controls.addEventListener( 'change', render ); // call this only in static scenes (i.e., if there is no animation loop)

            controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
            controls.dampingFactor = 0.05;

            controls.screenSpacePanning = false;

            controls.minDistance = 100;
            controls.maxDistance = 500;

            controls.maxPolarAngle = Math.PI / 2;

            // Lights

            var light = new THREE.DirectionalLight( 0xffffff );
            light.position.set( 1, 1, 1 );
            scene.add( light );

            var light = new THREE.DirectionalLight( 0x002288 );
            light.position.set( - 1, - 1, - 1 );
            scene.add( light );

            var light = new THREE.AmbientLight( 0x222222 );
            scene.add( light );
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            render();
        };

        function render() {
            renderer.render(scene, camera);
        }

        function setGlTFDownload(enable) {
            var downloadButton = document.getElementById('download-button');
            if (enable) {
                downloadButton.href = "data:application/json," + encodeURIComponent(JSON.stringify(swordglTF));
            }
            else {
                downloadButton.href = "javascript: void(0)"
            }
        }

        ///////////////////////////////////////////////////////////
        //                    GUI CONTROLS                       //
        ///////////////////////////////////////////////////////////

        export var forgeParams = {
            output: "gltf",
            seed: "Enter a seed value",
            template: "random",
            bladeParams: {
                color: "#7f7f7f",
                crossSection: "random"
            },
            guardParams: {
                color: "#7f5100"
            },
            handleParams: {
                color: "#cc5100"
            },
            pommelParams: {
                color: "#e5cc59"
            }
        };

        let guiFunctions = {
            "Random Seed": () => {},
            "Forge": forgeSword,
            "Random Forge": () => {
                seedController.setValue(randomSeed());
                forgeSword();
            },
            "Toggle Wireframe": () => {
                wireFrameEnabled = !wireFrameEnabled
                if (swordModel) {
                    if (wireFrameEnabled) {
                        swordModel.material = wireframeMaterial;
                    } else {
                        swordModel.material = importedMaterial;
                    }
                }
            }
        };

        const supportedCrossSections = {
            "Random": 'random',
            "Diamond": "diamond",
            "Hallow Ground": "hallow_ground",
            "Hexagonal": "hexagonal",
            "Thickened Diamond": "thickened_diamond",
            "Lenticular": "lenticular",
            "Fuller": "fuller",
            "Doule Fuller": "doule_fuller",
            "Broad Fuller": "broad_fuller"
        }

        const supportedTemplates = {
            'Random': 'random',
            'Short': 'short',
            'Long': 'long',
            'Great': 'great'
        }

        gui = new dat.GUI({
            "name": "Infiniforge Playground",
            "closeOnTop": "true"
        });

        gui.domElement.id = 'gui';

        gui.add(guiFunctions, "Random Forge");
        gui.add(guiFunctions, 'Forge');

        gui.add(guiFunctions, 'Random Seed')
            .setValue(() => {
                seedController.setValue(randomSeed());
            });

        seedController = gui.add(forgeParams, 'seed');

        gui.add(forgeParams, 'template', supportedTemplates);

        let bladeOptions = gui.addFolder("Blade Options");
        bladeOptions.add(forgeParams.bladeParams, "crossSection", supportedCrossSections);
        bladeOptions.addColor(forgeParams.bladeParams, "color");


        let guardOptions = gui.addFolder("Guard Options");
        guardOptions.addColor(forgeParams.guardParams, "color");

        let handleOptions = gui.addFolder("Handle Options");
        handleOptions.addColor(forgeParams.handleParams, "color");

        let pommelOptions = gui.addFolder("Pommel Options");
        pommelOptions.addColor(forgeParams.pommelParams, "color");


        gui.add(guiFunctions, 'Toggle Wireframe')

        document.getElementById("container").appendChild(gui.domElement);
    </script>
</body>

</html>
