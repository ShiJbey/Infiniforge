<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infiniforge Sandbox</title>
    <link rel="stylesheet" type="text/css" href="/style/style.css" />
</head>

<body>
    <div id="container">
        <canvas id="threejs-canvas"></canvas>
        <a id="download-button" href="javascript: void(0)" download="sword.gltf">
            <button>
                Download glTF
            </button>
        </a>
    </div>

    <script type="module">
        import { GUI } from '/node_modules/dat.gui.module.js';
        import * as THREE from '/node_modules/three.module.js';
        import { GLTFLoader } from '/js/GLTFLoader.js';
        import { OrbitControls } from '/js/OrbitControls.js';

        var scene, camera, renderer, controls;
        var swordModel, material, importedMaterial;
        var useWireFrame;
        var generationParams;
        var gui;
        var seedController, baseWidthController;
        var swordglTF;

        init();
        animate();


        const wireframeMaterial = new THREE.MeshBasicMaterial({
            color: 0x050505,
            wireframe: true
        });

        // Borrowed from MDN Math.Random()
        function getRandomInt(max) {
            return Math.floor(Math.random() * Math.floor(max));
        }

        // Creates a rnadom seed using upper case, lowercase
        // and numbers
        function randomSeed(seedLength = 7) {
            let seed = "";
            const numberAsciiOffset = 48;
            const lowercaseAsciiOffset = 97;
            const uppercaseAsciiOffset = 65;
            for (var i = 0; i < seedLength; i++) {
                var rand_num = Math.random();
                if (rand_num <= 0.33) {
                    seed += String.fromCharCode(numberAsciiOffset + getRandomInt(10));
                }
                else if (rand_num > 0.33 && rand_num <= 0.66) {
                    seed += String.fromCharCode(lowercaseAsciiOffset + getRandomInt(25));
                }
                else {
                    seed += String.fromCharCode(uppercaseAsciiOffset + getRandomInt(25));
                }
            }
            return seed;
        }

        function forgeSword() {

            var protocol = window.location.protocol;
            var host = window.location.host;
            var port = window.location.port;
            var weaponType = 'sword';
            var weaponStyle = generationParams['swordStyle'];
            var seed = generationParams['seed'];
            var options = generationParams.getGenerationParams();
            var requestString = `${protocol}//${host}/api/forge/${weaponType}/style/${weaponStyle}/seed/${seed}/options/${encodeURIComponent(JSON.stringify(options))}`;


            let httpRequest = new XMLHttpRequest();

            if (!httpRequest) {
                alert('Giving up :( Cannot create an XMLHTTP instance');
                return false;
            }

            httpRequest.onreadystatechange = () => {
                if (httpRequest.readyState === XMLHttpRequest.DONE) {
                    if (httpRequest.status === 200) {
                        loadModel(httpRequest.responseText);
                    }
                    else {
                        setGlTFDownload(false);
                        alert(httpRequest.responseText);
                    }
                }
            }

            httpRequest.onerror = (err) => {
                setGlTFDownload(false);
                alert(err);
            }

            httpRequest.open('GET', requestString, true);
            httpRequest.setRequestHeader('Content-Type', 'text/json');
            httpRequest.send();
        }

        function loadModel(data) {
            var loader = new GLTFLoader();
            loader.parse(
                JSON.stringify(data),
                '',
                (gltf) => {
                    scene.remove(swordModel);
                    swordModel = gltf.scene.children[0];
                    swordModel.rotation.y += Math.PI / 2;
                    importedMaterial = swordModel.material;
                    scene.add(swordModel);
                    // Save the json
                    swordglTF = res;
                    // Toggle the download
                    setGlTFDownload(true);
                },
                (err) => {
                    alert(err);
                });
        }

        function init() {
            var ThreeJSCanvas = document.getElementById("threejs-canvas");

            renderer = new THREE.WebGLRenderer({ canvas: ThreeJSCanvas, antialias: true });
            var renderer_rect = renderer.domElement.getBoundingClientRect();
            renderer.setSize(renderer_rect.width, renderer_rect.height);
            renderer.setPixelRatio(window.devicePixelRatio);

            var aspect = renderer_rect.width / renderer_rect.height;
            camera = new THREE.PerspectiveCamera(75, aspect, 1, 1000);
            camera.position.z = 2;
            camera.updateProjectionMatrix();

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);

            // controls

			controls = new OrbitControls( camera, renderer.domElement );

            //controls.addEventListener( 'change', render ); // call this only in static scenes (i.e., if there is no animation loop)

            controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
            controls.dampingFactor = 0.05;

            controls.screenSpacePanning = false;

            controls.minDistance = 100;
            controls.maxDistance = 500;

            controls.maxPolarAngle = Math.PI / 2;

            // Lights

            var light = new THREE.DirectionalLight( 0xffffff );
            light.position.set( 1, 1, 1 );
            scene.add( light );

            var light = new THREE.DirectionalLight( 0x002288 );
            light.position.set( - 1, - 1, - 1 );
            scene.add( light );

            var light = new THREE.AmbientLight( 0x222222 );
            scene.add( light );
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            render();
        };

        function render() {
            renderer.render(scene, camera);
        }

        function setGlTFDownload(enable) {
            var downloadButton = document.getElementById('download-button');
            if (enable) {
                downloadButton.href = "data:text/json," + encodeURIComponent(JSON.stringify(swordglTF));
            }
            else {
                downloadButton.href = "javascript: void(0)"
            }
        }

        ///////////////////////////////////////////////////////////
        //                    GUI CONTROLS                       //
        ///////////////////////////////////////////////////////////

        var SandboxManager = function () {
            this.seed = 'pizza';
            this.randomizeSeed = () => { };
            this.bladeColor = [127, 127, 127];
            this.guardColor = [127, 81, 0];
            this.handleColor = [204, 81, 0];
            this.pommelColor = [229, 204, 89];
            this.nBaseCPs = 3;
            this.nMidCPs = 5;
            this.nTipCPs = 2;
            this.nBaseSplinePoints = 5;
            this.nMidSplinePoints = 5;
            this.nTipSplinePoints = 2;
            this.randomizeNumCps = true;
            this.maxCPs = 7;
            this.minCPs = 2;
            this.evenSpacedBaseCPs = true;
            this.evenSpacedMidCPs = true;
            this.evenSpacedTipCPs = true;

            this.bladeThickness = 0.1;
            this.swordStyle = 'long';
            this.baseWidth = 0.3;

            this.bladeBaseProportion = 0.3;
            this.bladeMidProportion = 0.5;
            this.bladeWidthToleranceRatio = 0.6;
            this.Forge = () => {
                forgeSword();
            };
            this.ForgeRandom = () => {
                seedController.setValue(randomSeed());
                forgeSword();
            };
            this.wireframe = false;

            this.getGenerationParams = () => {
                return {
                    "bladeColor": this.bladeColor,
                    "guardColor": this.guardColor,
                    "handleColor": this.handleColor,
                    "pommelColor": this.pommelColor,
                    "nBaseCPs": this.nBaseCPs,
                    "nMidCPs": this.nMidCPs,
                    "nTipCPs": this.nTipCPs,
                    "nBaseSPlinePoints": this.nBaseSplinePoints,
                    "nMidSplinePoints": this.nMidSplinePoints,
                    "nTipSplinePoints": this.nTipSplinePoints,
                    "randomizeNumCps": this.randomizeNumCps,
                    "maxCPs": this.maxCPs,
                    "minCPs": this.minCPs,
                    "evenSpacedBaseCPs": this.evenSpacedBaseCPs,
                    "evenSpacedMidCPs": this.evenSpacedMidCPs,
                    "evenSpacedTipCPs": this.evenSpacedTipCPs,


                    "bladeBaseProportion": this.bladeBaseProportion,
                    "bladeMidProportion": this.bladeMidProportion,
                    "bladeWidthToleranceRatio": this.bladeWidthToleranceRatio,

                    "bladeThickness": this.bladeThickness,
                    "baseWidth": this.baseWidth
                };
            };
        };

        generationParams = new SandboxManager();

        gui = new GUI({ autoPlace: true });
        gui.domElement.id = 'gui';
        gui.domElement.class = 'gui';

        gui.remember(generationParams);

        gui.add(generationParams, 'ForgeRandom');
        gui.add(generationParams, 'Forge');

        seedController = gui.add(generationParams, 'seed');

        gui.add(generationParams, 'randomizeSeed').setValue(() => {
            seedController.setValue(randomSeed());
        });

        gui.add(generationParams, 'swordStyle', { 'Short': 'short', 'Long': 'long', 'Great': 'great' }).onChange((val) => { });

        var colorOptions = gui.addFolder("Color Options");
        colorOptions.addColor(generationParams, "bladeColor");
        colorOptions.addColor(generationParams, "guardColor");
        colorOptions.addColor(generationParams, "handleColor");
        colorOptions.addColor(generationParams, "pommelColor");

        var edgeSplineOptions = gui.addFolder("Edge Spline Options");

        var numControlPointsOptions = edgeSplineOptions.addFolder("Number of Control Points");
        numControlPointsOptions.add(generationParams, "nBaseCPs");
        numControlPointsOptions.add(generationParams, "nMidCPs");
        numControlPointsOptions.add(generationParams, "nTipCPs");
        numControlPointsOptions.add(generationParams, "randomizeNumCps");

        var splineSamplingOptions = edgeSplineOptions.addFolder("Spline Sampling");
        splineSamplingOptions.add(generationParams, "nBaseSplinePoints");
        splineSamplingOptions.add(generationParams, "nMidSplinePoints");
        splineSamplingOptions.add(generationParams, "nTipSplinePoints");

        var controlPointSpacing = edgeSplineOptions.addFolder("Control Point Spacing");
        controlPointSpacing.add(generationParams, "evenSpacedBaseCPs");
        controlPointSpacing.add(generationParams, "evenSpacedMidCPs");
        controlPointSpacing.add(generationParams, "evenSpacedTipCPs");


        gui.add(generationParams, 'baseWidth', 0.08, 0.3);
        gui.add(generationParams, 'bladeWidthToleranceRatio', 0.1, 1.0);
        gui.add(generationParams, 'bladeBaseProportion', 0.1, 0.3);
        gui.add(generationParams, 'bladeMidProportion', 0.1, 0.5);

        gui.add(generationParams, 'wireframe').onChange((enabled) => {
            if (swordModel) {
                if (enabled) {
                swordModel.material = wireframeMaterial;
                } else {
                    swordModel.material = importedMaterial;
                }
            }
        });

        document.getElementById("container").appendChild(gui.domElement);
    </script>
</body>

</html>
