<html>
<head>
</head>
<body>
</body>
<script src="node_modules/three/build/three.min.js"></script>
<script>
var scene, camera, renderer;
var material, mesh;
 
init();
animate();

function getLeftEdgeVerts(geom, bladeWidth) {
    var leftEdge = [];
    for (var i = 0; i < geom.vertices.length; i++) {
        if (geom.vertices[i].x == -bladeWidth / 2) {
            leftEdge.push(geom.vertices[i]);
        }
    }
    return leftEdge;
}

function getRightEdgeVerts(geom, bladeWidth) {
    var rightEdge = [];
    for (var i = 0; i < geom.vertices.length; i++) {
        if (geom.vertices[i].x == bladeWidth / 2) {
            rightEdge.push(geom.vertices[i]);
        }
    }
    return rightEdge;
}

function getTopVerts(geom, geomHeight=-1) {
    var topVerts = [];
    if (geomHeight != -1) {
        for (var i = 0; i < geom.vertices.length; i++) {
            if (geom.vertices[i].y == geomHeight) {
                topVerts.push(geom.vertices[i]);
            }
        }
    }
    else {
        var maxHeight = -1;
        var indexOfMax = -1;
        // Find the vertex with the greatest height
        for (var i = 0; i < geom.vertices.length; i++) {
            if (geom.vertices[i].y > maxHeight) {
                
                indexOfMax = i;
                maxHeight = geom.vertices[i].y;
            }
        }

        for (var i = 0; i < geom.vertices.length; i++) {
            if (geom.vertices[i].y == maxHeight) {
                topVerts.push(geom.vertices[i]);
            }
        }   
    }
    
    return topVerts;
}

function addHandle(swordGeom, bladeWidth, handleLength = 1.35, handleWidth = 0.1, numHands = 1) {
    var handleGeom = new THREE.CylinderGeometry( handleWidth, handleWidth, handleLength, 8)
    handleGeom.translate(0,-handleLength / 2,0);
    var mat = new THREE.MeshBasicMaterial( { color: 0xff0000, wireframe: true } );
    var handle = new THREE.Mesh(handleGeom, mat);

    handle.updateMatrix();
    swordGeom.merge(handle.geometry, handle.matrix);
}

function addGuard(swordGeom, bladeWidth = .6, bladethickness = .3, guardThickness = 1, guardBladeRatio = 4) {
    //var guardGeom = new THREE.BoxGeometry( guardBladeRatio * bladeWidth, guardThickness, guardBladeRatio * bladethickness);
    var guardGeom = new THREE.BoxGeometry( guardBladeRatio * bladeWidth, .2, guardThickness);
    var mat = new THREE.MeshBasicMaterial( { color: 0xff0000, wireframe: true } );
    var guard = new THREE.Mesh(guardGeom, mat);
    guard.updateMatrix();
    swordGeom.merge(guard.geometry, guard.matrix);

}

function addPommel(swordGeom, bladeWidth=0.6, handleLength = 1.35, pommelBladeWidthRatio = 0.50) {
    var pommelWidth = pommelBladeWidthRatio * bladeWidth;
    var pommelGeom = new THREE.SphereGeometry(pommelWidth, 5, 4);
    pommelGeom.translate(0,-handleLength,0);
    
    var mat = new THREE.MeshBasicMaterial( { color: 0xff0000, wireframe: true } );
    var pommel = new THREE.Mesh(pommelGeom, mat);

    pommel.updateMatrix();
    swordGeom.merge(pommel.geometry, pommel.matrix);
}

function createBladeCrossSection(bladeWidth, fullerDepth, fullerWidth, bladeThickness, applyFuller=true) {
    var verts = [];

    // Back side of the cross-section
    verts.push(new THREE.Vector3(-bladeWidth / 2, 0, 0));
    verts.push(new THREE.Vector3(-fullerWidth / 2, 0, -bladeThickness / 2));
    if (applyFuller) {
        verts.push(new THREE.Vector3(0, 0, (-bladeThickness / 2) + fullerDepth));
    }
    else {
        verts.push(new THREE.Vector3(0, 0, (-bladeThickness / 2)));
    }
    verts.push(new THREE.Vector3(fullerWidth / 2, 0, -bladeThickness / 2));
    verts.push(new THREE.Vector3(bladeWidth / 2, 0, 0));
    // Front side of cross-section
    verts.push(new THREE.Vector3(fullerWidth / 2, 0, bladeThickness / 2));
    if (applyFuller) {
        verts.push(new THREE.Vector3(0, 0, (bladeThickness / 2) - fullerDepth));
    }
    else {
        verts.push(new THREE.Vector3(0, 0, (bladeThickness / 2)));
    }
    verts.push(new THREE.Vector3(-fullerWidth / 2, 0, bladeThickness / 2));

    return verts;
}

function extrudeTopMultiple(geom, direction, numRepeat) {
    for (var i = 0; i < numRepeat; i++) {
        extrudeTop(geom,direction);
    }
}

function extrudeTop(geom, direction) {

    var topVerts = getTopVerts(geom);

    var extrudedGeom = extrudeVerts(topVerts, direction);

    // Now that we have the extrusion info we need to
    // add it to the existing geometry

    // Adds the new verts
    for (var i = 0; i < extrudedGeom.newVerts.length; i++) {
        geom.vertices.push(extrudedGeom.newVerts[i]);
    }

    // Adds new faces using the arrays of vertex references
    for (var i = 0; i < extrudedGeom.facesAsVerts.length; i++) {
        var face = extrudedGeom.facesAsVerts[i];
        geom.faces.push(new THREE.Face3(geom.vertices.indexOf(face[0]),
                                        geom.vertices.indexOf(face[1]),
                                        geom.vertices.indexOf(face[2])));
    }

}

/**
 * Extrudes a set of vertices in a given direction
 * The function retuens an object with an array of
 * vertices representing the new vertices and an array 
 * of faces for the faces that were made.
 * 
 * Returns: js object with the new verts defined
 */
function extrudeVerts(verts, direction) {
    // Faces here will be stored as arrays of size 3 with vertex references
    var geom = {"verts":verts, "oldVerts":verts, "newVerts":[], "faces":[], "facesAsVerts": []};
    
    if (verts.length == 0) {
        return geom;
    }
    
    // Loop through vertices and add verts that are translated
    // in the given direction    
    var priorVertCount = verts.length;
    for (var i = 0; i < priorVertCount; i++) {
        var newX = verts[i].x + direction.x;
        var newY = verts[i].y + direction.y;
        var newZ = verts[i].z + direction.z;
        var vert = new THREE.Vector3(newX, newY, newZ)
        geom.verts.push(vert);
        geom.newVerts.push(vert);
    }

    // Now we need to make the new faces
    // New faces will be specified by arrays of 3 vertici references
    var i = 0;
    var j = geom.verts.length / 2;
    // Assuming the verts at the bottom make a shape, we
    // need to give 2 faces or a quad to each side
    while (i < priorVertCount) {
    //for (var side = 0; side < geom.verts.length / 2; side++) {
        // On the last iteration we use 0 instead of i+1 or j+1
        if (i == priorVertCount - 1) {
            // CCW
            // Bottom-left triangle
            // geom.faces.push(new THREE.Face3(i,0,j));
            // Top-right triangle
            // geom.faces.push(new THREE.Face3(j, 0, geom.verts.length / 2));

            // CW
            // Bottom-left triangle
            geom.faces.push(new THREE.Face3(j,0,i));
            // Top-right triangle
            geom.faces.push(new THREE.Face3(geom.verts.length / 2,0,j));

            // CW (vertex arrays)
            // Bottom-left triangle
            geom.facesAsVerts.push([geom.verts[j],geom.verts[0],geom.verts[i]]);
            // Top-right triangle
            geom.facesAsVerts.push([geom.verts[geom.verts.length / 2],geom.verts[0],geom.verts[j]]);
        }
        // Otherwise all other sides are done the same
        else {
            // CCW
            // Bottom-left triangle
            //geom.faces.push(new THREE.Face3(i,i+1,j));
            // Top-right triangle
            //geom.faces.push(new THREE.Face3(j, i+1, j+1));

            // CW
            // Bottom-left triangle
            geom.faces.push(new THREE.Face3(j,i+1,i));
            // Top-right triangle
            geom.faces.push(new THREE.Face3(j+1, i+1, j));

            // CW (vertex arrays)
            // Bottom-left triangle
            geom.facesAsVerts.push([geom.verts[j],geom.verts[i+1],geom.verts[i]]);
            // Top-right triangle
            geom.facesAsVerts.push([geom.verts[j+1], geom.verts[i+1], geom.verts[j]]);
        }
        i++;
        j++;
    }

    return geom;
}

function addUVs(geom) {
    for (i =0; i < geom.faces.length; i++) {
        geom.faceVertexUvs[0].push([
            new THREE.Vector2(0,0),
            new THREE.Vector2(0,0),
            new THREE.Vector2(0,0)
        ]);
    }
}
 
function init() {
 
    scene = new THREE.Scene();
 
    camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 10000 );
    camera.position.z = 10;
 
    
    
    var bladeWidth = 1;
    var bladeHeight = 7;
    var bladeThickness = .5;
    var fullerDepth = .1;
    var fullerWidth = .2;
    var totalNumDivs = 8;


    var geometry = new THREE.Geometry();

    geometry.vertices = createBladeCrossSection(bladeWidth, fullerDepth, fullerWidth, bladeThickness );
    
    extrudeTopMultiple(geometry,new THREE.Vector3(0, 1, 0),7);
    addUVs(geometry);


    var top = getTopVerts(geometry, bladeHeight);
    for(var i = 0; i < top.length; i++) {
        top[i].x = 0;
        top[i].z = 0;
    }
    geometry.mergeVertices();


    addGuard(geometry);
    addHandle(geometry);
    addPommel(geometry);

    material = new THREE.MeshBasicMaterial( { color: 0xff0000, wireframe: true } );
    


    mesh = new THREE.Mesh( geometry, material );
    scene.add( mesh );
 
    renderer = new THREE.WebGLRenderer();
    renderer.setSize( window.innerWidth, window.innerHeight );
 
    document.body.appendChild( renderer.domElement );

 
 
}
 
function animate() {
 
    requestAnimationFrame( animate );
 
    mesh.rotation.y +=  .01 ;
    //mesh.rotation.z += 0.02;
    //mesh.rotation.x = Math.PI / 2;
 
    renderer.render( scene, camera );
 
}
</script>
</html>